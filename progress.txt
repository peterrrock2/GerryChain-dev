Progress to date (early May 2025):

This is intended to be a guide to a code review of what
I have done so far.

The modified code "works" - by which I mean that the regression
test I created from the GerryChain User Guide runs - it creates
a Graph from JSON, and does all the things needed to run a chain.

The biggest changes were in graph.py and tree.py.  

The changes to graph.py were to create a new Graph class that
is not a subclass of NetworkX.Graph.  The idea is to expunge 
all dependence on NetworkX everywhere except inside graph.py,
and making the Graph class not be a subclass was a device to
be sure that nothing leaked.

There are still leaks - but they are now identified via 
comments in the code as being hacks or kluges.

The changes to tree.py were to change the code from operating
on NetworkX.Graph objects (params were typically nx.Graph) and
instead have the code operate on the new Graph object.  After
modifying graph.py so that the new Graph object supported the
Pythonic syntax of the original Graph object, the changes to
tree.py ended up being straight-forward.

Note that there are some "hack/kluge" NetworkX dependencies
still in tree.py, but there are not that many.  One example
is a dependence on laplacian_matrix(...)

There are lots and lots of new comments in the code.  Many
of these are just notes to myself about what I have learned
or what I need to learn, or else they are TODO: comments
identifying work to be done in the future.  There are also
comments that are meant to make a code review easier...

There is one rather pervasive change that I made early on
that perhaps should be rolled back.  Before grokking how
Python allows you to control syntax (@property, __getattr__())
I implemented a routine in graph.py to get the dictionary for  
a node's data.  I did this because the syntax for doing 
so was different in NetworkX and RustworkX, but I now realize
that it would be easy to support the same syntax in both
with Pythonic cleverness ;-)

The new routine is called node_data(graph, node)
which in the NetworkX world is just graph.nodes[node]

Other things that might help before doing a code review:

* There is a long comment at the beginning of graph.py
  that you should read before anything else.

* I would review graph.py first and tree.py second as
  that is where most of the dependencies are/were.

* The work remaining is to implement the algorithms that
  we need that are currently NX algorithms so that they
  work with RX, such as: laplacian_matrix(), 
  is_connected(), ... and to implement the many Graph
  operations for RX (see comments with: RX version NYI...)
  When all of that is done (and tested), it will be
  time to add logic so that when a Graph is added to
  a Partition, it is not just frozen, but is also
  converted to be based on RustworkX.

* Unfortuneatly the diff for graph.py does not make
  clear what is new and what is old.  The OriginalGraph
  code is just a copy of the Graph code from before.
  I saved that code so that I could write tests to
  verify that the new Graph was behaving the same way
  as the old Graph.

  The new Graph code was put together from smushing
  the old Graph code and the FrozenGraph code.  The
  FrozenGraph code was useful becaue it showed how
  to replicate behavior when not a subclass of 
  NetworkX.Graph, and the old Graph code was useful
  just to make sure I had covered everything.


