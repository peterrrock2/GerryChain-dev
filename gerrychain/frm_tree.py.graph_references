References to "graph" objects in tree.py

* References to graph.nodes as a dict of dict

    graph.nodes[edge[0]][key] != graph.nodes[edge[1]][key]
    or graph.nodes[edge[1]][key] is None
    populated_graph.graph.nodes[cut.edge[0]].get(key),
    populated_graph.graph.nodes[cut.edge[1]].get(key),
    populations = {node: graph.nodes[node][pop_col] for node in graph.node_indices}
    part_pop += graph.nodes[node][pop_col]
    part_pop += graph.nodes[node][pop_col]
    part_pop += graph.nodes[node][pop_col]
    part_pop += graph.nodes[node][pop_col]
    part_pop += graph.nodes[node][pop_col]
    chunk_pop += graph.nodes[node][pop_col]
    part_pop += graph.nodes[node][pop_col]

* References to graph.edges as a dict
  
  ??? - I thought edges was a dict of dict of dict requiring IDs of both nodes...

    for edge in graph.edges():
    graph.edges[edge]["random_weight"] = weight
    f"Graph(nodes={len(self.graph.nodes)}, edges={len(self.graph.edges)})"
    weight=h.graph.edges[e].get("random_weight", random.random()),
    weight=h.graph.edges[e].get("random_weight", wt),
    weight=h.graph.edges[e].get("random_weight", wt),

* References to graph.node_indices (I think as a set)

    root = choice(list(graph.node_indices))
    for node in graph.node_indices:
    remaining_nodes = graph.node_indices
    remaining_nodes = graph.node_indices
    for node in graph.node_indices:
    populations = {node: graph.nodes[node][pop_col] for node in graph.node_indices}

* Reference to graph.neighbors()

    next_node[u] = choice(list(graph.neighbors(u)))

* Reference to a function param that takes a graph as a param.
  Need to identify all functions that are passed as a param and make sure
  that they can handle the given param (NetworkX vs. RustworkX)

    spanning_tree = spanning_tree_fn(graph)

* References to graph.subgraph:

    graph.subgraph(remaining_nodes),
    graph.subgraph(remaining_nodes),
    graph.subgraph(remaining_nodes),
    graph.subgraph(remaining_nodes),
    graph.subgraph(remaining_nodes),
    graph.subgraph(remaining_nodes),
    graph.subgraph(chunk),

* References to graph.nodes as an iterable

    self.subsets = {node: {node} for node in graph.nodes}
    self._degrees = {node: graph.degree(node) for node in graph.nodes}

* Not sure what this is doing - check it out...

    return iter(self.graph)

* Not sure what this would mean in a RustworkX world...

    subset=frozenset(set(h.graph.nodes) - _part_nodes(node, succ)),

* References to graph.nodes converted to a set.

    remaining_nodes = set(graph.nodes)
    return [set(graph.nodes)]
    return [set(nodes), set(graph.nodes) - set(nodes)]
    remaining_nodes = set(graph.nodes)

* References to predecessors and successors functions - need to make
  sure that they can handle both NetworkX and RustworkX graphs.

    pred = predecessors(h.graph, root)
    succ = successors(h.graph, root)
